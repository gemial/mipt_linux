Процессы в Linux ############################################

:date: 2020-10-07 09:00 :summary: Процессы в Linux :status: published
:author: Богдан Е.С.

.. contents:: Содержание

.. role: bash(code) :language: bash

Процессы в Linux
----------------

**Процесс**- это программа и её данные, загруженные в память компьютера.
Процессы могут запускать другие процессы для выполнения параллельных
задач или других целей такие процессы называются **дочерними**. Для них
выделяется отдельная область в памяти.

В линуксе присутствует внешнее управление процессами - механизм сигналов
signal(который является простейшей формой межпроцессного
взаимодействия). Каждый сигнал имеет свой обработчик, определяющий
поведение процесса при отсылке ему этого сигнала. Этот обработчик
является некоторым набором инструкций программы (подпрограммой), которым
передается управление при доставке сигнала процессу. Каждому процессу
назначаются обработчики «по умолчанию», в большинстве случаев приводящие
к завершению процесса. Далее мы рассмотрим какие сигналы бывают и для
каких действий могут использоваться.

Просмотр текущих процессов
--------------------------

ps :sub:`~`

Самый простой способ посмотреть список процессов, запущенных в текущей
командой оболочке(на сервере), использовать команду :bash:``ps`` без
параметров:

.. code-block:: bash

::

    $ ps -l
    F S UID    PID  PPID C PRI NI ADDR SZ WCHAN TTY
    0 S 1000 11260 11255 0  80  0 -  2208 -     pts/0  00
    0 R 1000 19881 11260 0  80  0 -  2637 -     pts/0  00

Вот значение основных колонок в выводе утилиты:

``UID`` - имя пользователя, от имени которого работает процесс;

``PID`` - идентификатор пользователя;

``PPID`` - идентификатор родительского процесса пользователя;

``C`` - расходование ресурсов процессора, в процентах;

``SZ`` - размер процесса;

``RSS`` - реальный размер процесса в памяти;

``PSR`` - ядро процессора, на котором выполняется процесс;

``STIME`` - время, когда процесс был запущен;

``TTY`` - если процесс привязан к терминалу, то здесь будет выведен его
номер;

``TIME`` - общее время выполнения процесса (user + system);

``CMD`` - команда, которой был запущен процесс, если программа не может
прочитать аргументы процесса, он будет выведен в квадратных скобках;

Чтобы посмотреть список процессов в виде дерева, и понимать какой
процесс имеет какие дочерние процессы, можно выполнить команду:

.. code-block:: bash

::

    $ ps -efH

Чтобы посмотреть все активные на данный момент процессы в linux,
используется сочетание опций :bash:``aux``:

.. code-block:: bash

::

    $ps aux

top :sub:`~` Также чтобы просматривать список запущенных процессов в
режиме реального времени, можно использовать утилиту :bash:``top``,
которая выводит список процессов:

.. code-block:: bash

::

    $ top
    USER PID  PPID PR NI VIRT   RES   SHR   S %CPU  %MEM TIME+    COMMAND
    usr  920 4613 20 0  51520  4424  3536   S 33,3  0,0  13:59.53 top

Чтобы отслеживать список процессов конкретного пользователя на сервере:

.. code-block:: bash

::

    $top -u 

Колонки, которые выводит программа очень похожи на ps:

``PID`` - идентификатор процесса;

``USER`` - имя пользователя, от имени которого выполняется процесс;

``PR`` - приоритет планировщика, установленный для процесса;

``NI`` - рекомендуемый приоритет процесса. Это значение можно менять,
может не совпадать с реальным приоритетом планировщика;

``VIRT`` - всё, что находится в памяти, используется или зарезервировано
для использования;

``RES`` - всё, что находится в оперативной памяти и относится к
процессу. Расшифровывается как Resident Memory Size, указывается в
килобайтах;

``SHR``- часть памяти из RES, которую занимают ресурсы, доступные для
использования другим процессам. Расшифровывается - Shared Memory Size. S
- состояние процесса: D - ожидает завершения операции, R - запущен, S -
спит, T - остановлен, t - остановлен отладчиком, Z - зомби;

``%CPU`` - процент использования ресурсов процессора;

``%MEM`` - процент использования ресурсов оперативной памяти на основе
колонки RES;

``TIME`` - обще процессорное время, которое процесс использовал с
момента запуска;

``COMAND`` - команда, с помощью которой был запущен процесс.

Выход из top - клавиша *q*.

Другое :sub:`[STRIKEOUT:~]` Ещё более мощная утилита для просмотра
запущенных процессов в Linux - htop. Пользоваться ею намного удобнее.
Здесь поддерживаются не только горячие клавиши, но и управление мышью. А
ещё она выводит всё в цвете, поэтому смотреть на данные намного
приятнее.

Смотреть запущенные процессы можно не только в терминале, но и в
графическом интерфейсе. Для этого можно использовать утилиту Gnome
Monitor.

Переключение процессов, запуск в фоне
-------------------------------------

Программа может находится в основном режиме (:bash:``fg``) или в фоновом
(:bash:``bg``). Различие этих режимов состоит в том, что в фоновом
режиме можно запустить несколько(неограниченное число) программ (+
команды, введённые в терминал также будут выполняться), в то время как в
активном режиме может находиться только 1 программа. Также различие
заключается в том, что при закрытии терминала программа в фоновом режиме
не закроется, а в активном - закроется.

Чтобы посмотреть все запущенные фоновые программы используется команда
:bash:``jobs``. Для каждой программы показывается её статус: running -
запущено, suspended - приостановлено( :bash:\ ``fg`` и ``ctrl Z``),
stopped, done, exit.

Чтобы запустить определённую программу в фоновом режиме нужно добавить
*&* в конце имени программы или .

:bash:``fg`` выводит программу из фонового режима.

:bash:``fg %`` номер команды или (аналогично bg) - продолжить программу
с данным номером(вывести из фонового режима).

Просто :bash:``fg`` выведет последнюю добавленную в фоновый режим
программу ( в jobs помечена знаком +)

Также программы можно по-разному завершать, приостанавливать, продолжать
в разных режимах:

-  Например, сочетание клавиш ``Ctrl C`` прерывает выполнение текущей
   программы (контролируется сигналом SIGINT). Программа может избежать
   закрытия перехватив сигнал (например, питоном и OC).

-  Также прервать выполнение программы можно с помощью ``Ctrl \`` (
   контролируется SIGQUIT, который нельзя перехватить питоном, но можно
   oc(сложнее, тк сразу закрывает)).

-  Сочетание клавиш ``Ctrl D`` завершает сессию.

-  ``ctrl z`` - приостановка, далее можно продолжить программу
   (:bash:``fg``) или продолжить в фоновом режиме (:bash:``bg``);
   контролируется сигналом SIGTSP.

Пример реализации: gedit закрывается ctrl c (и команды введенные в
терминал, пока был запущен firefox). Если ввести ``ctrl z`` - программа
не реагирует на нажатия. Если после этого ввести :bash:``fg`` -
произойдет выполнение всех команд, которые были введены и нет реакции в
терминале; :bash:``bg`` - программа реагирует на нажатия и также
выполняются команды в терминале.

Завершить процесс на сервере можно с помощью команды :bash:``kill`` (
контролируется SIGTERM, который можно перехватить OC).

.. code-block:: bash

::

    $ kill

После команды :bash:``kill`` программа не отображается в ps.

В самом крайнем случае используют :bash:``kill -9`` (контролируется
сигналом SIGKILL, который нельзя перехватить).

.. code-block:: bash

::

    $ kill -9

Эту команду используют, чтобы убить программу(если завис).

Выводы
------

Таким образом, мы рассмотрели процессы в линуксе, научились
просматривать процессы в системе и текущие процессы, рассмотрели внешний
контроль над процессами.
